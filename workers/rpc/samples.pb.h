// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: samples.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_samples_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_samples_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_samples_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_samples_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_samples_2eproto;
class EmptyRequest;
class EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class Episode;
class EpisodeDefaultTypeInternal;
extern EpisodeDefaultTypeInternal _Episode_default_instance_;
class ReadRequest;
class ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class Sample;
class SampleDefaultTypeInternal;
extern SampleDefaultTypeInternal _Sample_default_instance_;
class ShmInfoResponse;
class ShmInfoResponseDefaultTypeInternal;
extern ShmInfoResponseDefaultTypeInternal _ShmInfoResponse_default_instance_;
class StatInfoResponse;
class StatInfoResponseDefaultTypeInternal;
extern StatInfoResponseDefaultTypeInternal _StatInfoResponse_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::EmptyRequest* Arena::CreateMaybeMessage<::EmptyRequest>(Arena*);
template<> ::Episode* Arena::CreateMaybeMessage<::Episode>(Arena*);
template<> ::ReadRequest* Arena::CreateMaybeMessage<::ReadRequest>(Arena*);
template<> ::Sample* Arena::CreateMaybeMessage<::Sample>(Arena*);
template<> ::ShmInfoResponse* Arena::CreateMaybeMessage<::ShmInfoResponse>(Arena*);
template<> ::StatInfoResponse* Arena::CreateMaybeMessage<::StatInfoResponse>(Arena*);
template<> ::StatusResponse* Arena::CreateMaybeMessage<::StatusResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Sample :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sample) */ {
 public:
  Sample();
  virtual ~Sample();

  Sample(const Sample& from);
  Sample(Sample&& from) noexcept
    : Sample() {
    *this = ::std::move(from);
  }

  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sample& operator=(Sample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample* internal_default_instance() {
    return reinterpret_cast<const Sample*>(
               &_Sample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Sample& a, Sample& b) {
    a.Swap(&b);
  }
  inline void Swap(Sample* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sample* New() const final {
    return CreateMaybeMessage<Sample>(nullptr);
  }

  Sample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sample>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sample& from);
  void MergeFrom(const Sample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sample* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sample";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kActionFieldNumber = 2,
    kNextStateFieldNumber = 4,
    kRewardFieldNumber = 3,
    kMaskFieldNumber = 5,
  };
  // repeated float state = 1 [packed = true];
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  private:
  float _internal_state(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_state() const;
  void _internal_add_state(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_state();
  public:
  float state(int index) const;
  void set_state(int index, float value);
  void add_state(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      state() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_state();

  // repeated float action = 2 [packed = true];
  int action_size() const;
  private:
  int _internal_action_size() const;
  public:
  void clear_action();
  private:
  float _internal_action(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_action() const;
  void _internal_add_action(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_action();
  public:
  float action(int index) const;
  void set_action(int index, float value);
  void add_action(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      action() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_action();

  // repeated float next_state = 4 [packed = true];
  int next_state_size() const;
  private:
  int _internal_next_state_size() const;
  public:
  void clear_next_state();
  private:
  float _internal_next_state(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_next_state() const;
  void _internal_add_next_state(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_next_state();
  public:
  float next_state(int index) const;
  void set_next_state(int index, float value);
  void add_next_state(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      next_state() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_next_state();

  // required float reward = 3 [default = 0];
  bool has_reward() const;
  private:
  bool _internal_has_reward() const;
  public:
  void clear_reward();
  float reward() const;
  void set_reward(float value);
  private:
  float _internal_reward() const;
  void _internal_set_reward(float value);
  public:

  // optional float mask = 5 [default = 1];
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  float mask() const;
  void set_mask(float value);
  private:
  float _internal_mask() const;
  void _internal_set_mask(float value);
  public:

  // @@protoc_insertion_point(class_scope:Sample)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > state_;
  mutable std::atomic<int> _state_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > action_;
  mutable std::atomic<int> _action_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > next_state_;
  mutable std::atomic<int> _next_state_cached_byte_size_;
  float reward_;
  float mask_;
  friend struct ::TableStruct_samples_2eproto;
};
// -------------------------------------------------------------------

class Episode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Episode) */ {
 public:
  Episode();
  virtual ~Episode();

  Episode(const Episode& from);
  Episode(Episode&& from) noexcept
    : Episode() {
    *this = ::std::move(from);
  }

  inline Episode& operator=(const Episode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Episode& operator=(Episode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Episode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Episode* internal_default_instance() {
    return reinterpret_cast<const Episode*>(
               &_Episode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Episode& a, Episode& b) {
    a.Swap(&b);
  }
  inline void Swap(Episode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Episode* New() const final {
    return CreateMaybeMessage<Episode>(nullptr);
  }

  Episode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Episode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Episode& from);
  void MergeFrom(const Episode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Episode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Episode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplesFieldNumber = 1,
    kWorkerIdFieldNumber = 2,
  };
  // repeated .Sample samples = 1;
  int samples_size() const;
  private:
  int _internal_samples_size() const;
  public:
  void clear_samples();
  ::Sample* mutable_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sample >*
      mutable_samples();
  private:
  const ::Sample& _internal_samples(int index) const;
  ::Sample* _internal_add_samples();
  public:
  const ::Sample& samples(int index) const;
  ::Sample* add_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sample >&
      samples() const;

  // optional int32 worker_id = 2;
  bool has_worker_id() const;
  private:
  bool _internal_has_worker_id() const;
  public:
  void clear_worker_id();
  ::PROTOBUF_NAMESPACE_ID::int32 worker_id() const;
  void set_worker_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_worker_id() const;
  void _internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Episode)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sample > samples_;
  ::PROTOBUF_NAMESPACE_ID::int32 worker_id_;
  friend struct ::TableStruct_samples_2eproto;
};
// -------------------------------------------------------------------

class EmptyRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EmptyRequest) */ {
 public:
  EmptyRequest();
  virtual ~EmptyRequest();

  EmptyRequest(const EmptyRequest& from);
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmptyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmptyRequest* New() const final {
    return CreateMaybeMessage<EmptyRequest>(nullptr);
  }

  EmptyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmptyRequest& from);
  void MergeFrom(const EmptyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EmptyRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaceholderFieldNumber = 1,
  };
  // optional int32 placeholder = 1;
  bool has_placeholder() const;
  private:
  bool _internal_has_placeholder() const;
  public:
  void clear_placeholder();
  ::PROTOBUF_NAMESPACE_ID::int32 placeholder() const;
  void set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_placeholder() const;
  void _internal_set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:EmptyRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 placeholder_;
  friend struct ::TableStruct_samples_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadRequest) */ {
 public:
  ReadRequest();
  virtual ~ReadRequest();

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const final {
    return CreateMaybeMessage<ReadRequest>(nullptr);
  }

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadRequest& from);
  void MergeFrom(const ReadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchSizeFieldNumber = 1,
  };
  // optional int32 batch_size = 1;
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ReadRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  friend struct ::TableStruct_samples_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return CreateMaybeMessage<StatusResponse>(nullptr);
  }

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorTextFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // optional string error_text = 2;
  bool has_error_text() const;
  private:
  bool _internal_has_error_text() const;
  public:
  void clear_error_text();
  const std::string& error_text() const;
  void set_error_text(const std::string& value);
  void set_error_text(std::string&& value);
  void set_error_text(const char* value);
  void set_error_text(const char* value, size_t size);
  std::string* mutable_error_text();
  std::string* release_error_text();
  void set_allocated_error_text(std::string* error_text);
  private:
  const std::string& _internal_error_text() const;
  void _internal_set_error_text(const std::string& value);
  std::string* _internal_mutable_error_text();
  public:

  // required int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:StatusResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_text_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_samples_2eproto;
};
// -------------------------------------------------------------------

class ShmInfoResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ShmInfoResponse) */ {
 public:
  ShmInfoResponse();
  virtual ~ShmInfoResponse();

  ShmInfoResponse(const ShmInfoResponse& from);
  ShmInfoResponse(ShmInfoResponse&& from) noexcept
    : ShmInfoResponse() {
    *this = ::std::move(from);
  }

  inline ShmInfoResponse& operator=(const ShmInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShmInfoResponse& operator=(ShmInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShmInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShmInfoResponse* internal_default_instance() {
    return reinterpret_cast<const ShmInfoResponse*>(
               &_ShmInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShmInfoResponse& a, ShmInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShmInfoResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShmInfoResponse* New() const final {
    return CreateMaybeMessage<ShmInfoResponse>(nullptr);
  }

  ShmInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShmInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShmInfoResponse& from);
  void MergeFrom(const ShmInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShmInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShmInfoResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShmidFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // required int32 shmid = 1;
  bool has_shmid() const;
  private:
  bool _internal_has_shmid() const;
  public:
  void clear_shmid();
  ::PROTOBUF_NAMESPACE_ID::int32 shmid() const;
  void set_shmid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_shmid() const;
  void _internal_set_shmid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ShmInfoResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 shmid_;
  ::PROTOBUF_NAMESPACE_ID::int32 offset_;
  friend struct ::TableStruct_samples_2eproto;
};
// -------------------------------------------------------------------

class StatInfoResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatInfoResponse) */ {
 public:
  StatInfoResponse();
  virtual ~StatInfoResponse();

  StatInfoResponse(const StatInfoResponse& from);
  StatInfoResponse(StatInfoResponse&& from) noexcept
    : StatInfoResponse() {
    *this = ::std::move(from);
  }

  inline StatInfoResponse& operator=(const StatInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatInfoResponse& operator=(StatInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatInfoResponse* internal_default_instance() {
    return reinterpret_cast<const StatInfoResponse*>(
               &_StatInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StatInfoResponse& a, StatInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatInfoResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatInfoResponse* New() const final {
    return CreateMaybeMessage<StatInfoResponse>(nullptr);
  }

  StatInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatInfoResponse& from);
  void MergeFrom(const StatInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatInfoResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_samples_2eproto);
    return ::descriptor_table_samples_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumSamplesFieldNumber = 1,
    kNumReadsFieldNumber = 2,
    kNumWritesFieldNumber = 3,
  };
  // required int64 num_samples = 1;
  bool has_num_samples() const;
  private:
  bool _internal_has_num_samples() const;
  public:
  void clear_num_samples();
  ::PROTOBUF_NAMESPACE_ID::int64 num_samples() const;
  void set_num_samples(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_samples() const;
  void _internal_set_num_samples(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 num_reads = 2;
  bool has_num_reads() const;
  private:
  bool _internal_has_num_reads() const;
  public:
  void clear_num_reads();
  ::PROTOBUF_NAMESPACE_ID::int32 num_reads() const;
  void set_num_reads(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_reads() const;
  void _internal_set_num_reads(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 num_writes = 3;
  bool has_num_writes() const;
  private:
  bool _internal_has_num_writes() const;
  public:
  void clear_num_writes();
  ::PROTOBUF_NAMESPACE_ID::int32 num_writes() const;
  void set_num_writes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_writes() const;
  void _internal_set_num_writes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:StatInfoResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_samples_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_reads_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_writes_;
  friend struct ::TableStruct_samples_2eproto;
};
// ===================================================================

class MempoolService_Stub;

class MempoolService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MempoolService() {};
 public:
  virtual ~MempoolService();

  typedef MempoolService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void HelloWorld(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void SaveSamples(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::Episode* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ReadSamples(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::ReadRequest* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void CloseShmBuffer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetStatInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::StatInfoResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetShmInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::ShmInfoResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MempoolService);
};

class MempoolService_Stub : public MempoolService {
 public:
  MempoolService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  MempoolService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~MempoolService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements MempoolService ------------------------------------------

  void HelloWorld(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  void SaveSamples(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::Episode* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  void ReadSamples(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::ReadRequest* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  void CloseShmBuffer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::StatusResponse* response,
                       ::google::protobuf::Closure* done);
  void GetStatInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::StatInfoResponse* response,
                       ::google::protobuf::Closure* done);
  void GetShmInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::EmptyRequest* request,
                       ::ShmInfoResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MempoolService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Sample

// repeated float state = 1 [packed = true];
inline int Sample::_internal_state_size() const {
  return state_.size();
}
inline int Sample::state_size() const {
  return _internal_state_size();
}
inline void Sample::clear_state() {
  state_.Clear();
}
inline float Sample::_internal_state(int index) const {
  return state_.Get(index);
}
inline float Sample::state(int index) const {
  // @@protoc_insertion_point(field_get:Sample.state)
  return _internal_state(index);
}
inline void Sample::set_state(int index, float value) {
  state_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sample.state)
}
inline void Sample::_internal_add_state(float value) {
  state_.Add(value);
}
inline void Sample::add_state(float value) {
  _internal_add_state(value);
  // @@protoc_insertion_point(field_add:Sample.state)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Sample::_internal_state() const {
  return state_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Sample::state() const {
  // @@protoc_insertion_point(field_list:Sample.state)
  return _internal_state();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Sample::_internal_mutable_state() {
  return &state_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Sample::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:Sample.state)
  return _internal_mutable_state();
}

// repeated float action = 2 [packed = true];
inline int Sample::_internal_action_size() const {
  return action_.size();
}
inline int Sample::action_size() const {
  return _internal_action_size();
}
inline void Sample::clear_action() {
  action_.Clear();
}
inline float Sample::_internal_action(int index) const {
  return action_.Get(index);
}
inline float Sample::action(int index) const {
  // @@protoc_insertion_point(field_get:Sample.action)
  return _internal_action(index);
}
inline void Sample::set_action(int index, float value) {
  action_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sample.action)
}
inline void Sample::_internal_add_action(float value) {
  action_.Add(value);
}
inline void Sample::add_action(float value) {
  _internal_add_action(value);
  // @@protoc_insertion_point(field_add:Sample.action)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Sample::_internal_action() const {
  return action_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Sample::action() const {
  // @@protoc_insertion_point(field_list:Sample.action)
  return _internal_action();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Sample::_internal_mutable_action() {
  return &action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Sample::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:Sample.action)
  return _internal_mutable_action();
}

// required float reward = 3 [default = 0];
inline bool Sample::_internal_has_reward() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Sample::has_reward() const {
  return _internal_has_reward();
}
inline void Sample::clear_reward() {
  reward_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Sample::_internal_reward() const {
  return reward_;
}
inline float Sample::reward() const {
  // @@protoc_insertion_point(field_get:Sample.reward)
  return _internal_reward();
}
inline void Sample::_internal_set_reward(float value) {
  _has_bits_[0] |= 0x00000001u;
  reward_ = value;
}
inline void Sample::set_reward(float value) {
  _internal_set_reward(value);
  // @@protoc_insertion_point(field_set:Sample.reward)
}

// repeated float next_state = 4 [packed = true];
inline int Sample::_internal_next_state_size() const {
  return next_state_.size();
}
inline int Sample::next_state_size() const {
  return _internal_next_state_size();
}
inline void Sample::clear_next_state() {
  next_state_.Clear();
}
inline float Sample::_internal_next_state(int index) const {
  return next_state_.Get(index);
}
inline float Sample::next_state(int index) const {
  // @@protoc_insertion_point(field_get:Sample.next_state)
  return _internal_next_state(index);
}
inline void Sample::set_next_state(int index, float value) {
  next_state_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sample.next_state)
}
inline void Sample::_internal_add_next_state(float value) {
  next_state_.Add(value);
}
inline void Sample::add_next_state(float value) {
  _internal_add_next_state(value);
  // @@protoc_insertion_point(field_add:Sample.next_state)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Sample::_internal_next_state() const {
  return next_state_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Sample::next_state() const {
  // @@protoc_insertion_point(field_list:Sample.next_state)
  return _internal_next_state();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Sample::_internal_mutable_next_state() {
  return &next_state_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Sample::mutable_next_state() {
  // @@protoc_insertion_point(field_mutable_list:Sample.next_state)
  return _internal_mutable_next_state();
}

// optional float mask = 5 [default = 1];
inline bool Sample::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Sample::has_mask() const {
  return _internal_has_mask();
}
inline void Sample::clear_mask() {
  mask_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Sample::_internal_mask() const {
  return mask_;
}
inline float Sample::mask() const {
  // @@protoc_insertion_point(field_get:Sample.mask)
  return _internal_mask();
}
inline void Sample::_internal_set_mask(float value) {
  _has_bits_[0] |= 0x00000002u;
  mask_ = value;
}
inline void Sample::set_mask(float value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:Sample.mask)
}

// -------------------------------------------------------------------

// Episode

// repeated .Sample samples = 1;
inline int Episode::_internal_samples_size() const {
  return samples_.size();
}
inline int Episode::samples_size() const {
  return _internal_samples_size();
}
inline void Episode::clear_samples() {
  samples_.Clear();
}
inline ::Sample* Episode::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:Episode.samples)
  return samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sample >*
Episode::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:Episode.samples)
  return &samples_;
}
inline const ::Sample& Episode::_internal_samples(int index) const {
  return samples_.Get(index);
}
inline const ::Sample& Episode::samples(int index) const {
  // @@protoc_insertion_point(field_get:Episode.samples)
  return _internal_samples(index);
}
inline ::Sample* Episode::_internal_add_samples() {
  return samples_.Add();
}
inline ::Sample* Episode::add_samples() {
  // @@protoc_insertion_point(field_add:Episode.samples)
  return _internal_add_samples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sample >&
Episode::samples() const {
  // @@protoc_insertion_point(field_list:Episode.samples)
  return samples_;
}

// optional int32 worker_id = 2;
inline bool Episode::_internal_has_worker_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Episode::has_worker_id() const {
  return _internal_has_worker_id();
}
inline void Episode::clear_worker_id() {
  worker_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Episode::_internal_worker_id() const {
  return worker_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Episode::worker_id() const {
  // @@protoc_insertion_point(field_get:Episode.worker_id)
  return _internal_worker_id();
}
inline void Episode::_internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  worker_id_ = value;
}
inline void Episode::set_worker_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:Episode.worker_id)
}

// -------------------------------------------------------------------

// EmptyRequest

// optional int32 placeholder = 1;
inline bool EmptyRequest::_internal_has_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EmptyRequest::has_placeholder() const {
  return _internal_has_placeholder();
}
inline void EmptyRequest::clear_placeholder() {
  placeholder_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EmptyRequest::_internal_placeholder() const {
  return placeholder_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EmptyRequest::placeholder() const {
  // @@protoc_insertion_point(field_get:EmptyRequest.placeholder)
  return _internal_placeholder();
}
inline void EmptyRequest::_internal_set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  placeholder_ = value;
}
inline void EmptyRequest::set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_placeholder(value);
  // @@protoc_insertion_point(field_set:EmptyRequest.placeholder)
}

// -------------------------------------------------------------------

// ReadRequest

// optional int32 batch_size = 1;
inline bool ReadRequest::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReadRequest::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void ReadRequest::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReadRequest::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReadRequest::batch_size() const {
  // @@protoc_insertion_point(field_get:ReadRequest.batch_size)
  return _internal_batch_size();
}
inline void ReadRequest::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  batch_size_ = value;
}
inline void ReadRequest::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:ReadRequest.batch_size)
}

// -------------------------------------------------------------------

// StatusResponse

// required int32 status = 1;
inline bool StatusResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusResponse::has_status() const {
  return _internal_has_status();
}
inline void StatusResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusResponse::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void StatusResponse::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:StatusResponse.status)
}

// optional string error_text = 2;
inline bool StatusResponse::_internal_has_error_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusResponse::has_error_text() const {
  return _internal_has_error_text();
}
inline void StatusResponse::clear_error_text() {
  error_text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusResponse::error_text() const {
  // @@protoc_insertion_point(field_get:StatusResponse.error_text)
  return _internal_error_text();
}
inline void StatusResponse::set_error_text(const std::string& value) {
  _internal_set_error_text(value);
  // @@protoc_insertion_point(field_set:StatusResponse.error_text)
}
inline std::string* StatusResponse::mutable_error_text() {
  // @@protoc_insertion_point(field_mutable:StatusResponse.error_text)
  return _internal_mutable_error_text();
}
inline const std::string& StatusResponse::_internal_error_text() const {
  return error_text_.GetNoArena();
}
inline void StatusResponse::_internal_set_error_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusResponse::set_error_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:StatusResponse.error_text)
}
inline void StatusResponse::set_error_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StatusResponse.error_text)
}
inline void StatusResponse::set_error_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StatusResponse.error_text)
}
inline std::string* StatusResponse::_internal_mutable_error_text() {
  _has_bits_[0] |= 0x00000001u;
  return error_text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusResponse::release_error_text() {
  // @@protoc_insertion_point(field_release:StatusResponse.error_text)
  if (!_internal_has_error_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_text_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_error_text(std::string* error_text) {
  if (error_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_text);
  // @@protoc_insertion_point(field_set_allocated:StatusResponse.error_text)
}

// -------------------------------------------------------------------

// ShmInfoResponse

// required int32 shmid = 1;
inline bool ShmInfoResponse::_internal_has_shmid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShmInfoResponse::has_shmid() const {
  return _internal_has_shmid();
}
inline void ShmInfoResponse::clear_shmid() {
  shmid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ShmInfoResponse::_internal_shmid() const {
  return shmid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ShmInfoResponse::shmid() const {
  // @@protoc_insertion_point(field_get:ShmInfoResponse.shmid)
  return _internal_shmid();
}
inline void ShmInfoResponse::_internal_set_shmid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  shmid_ = value;
}
inline void ShmInfoResponse::set_shmid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_shmid(value);
  // @@protoc_insertion_point(field_set:ShmInfoResponse.shmid)
}

// optional int32 offset = 2;
inline bool ShmInfoResponse::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShmInfoResponse::has_offset() const {
  return _internal_has_offset();
}
inline void ShmInfoResponse::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ShmInfoResponse::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ShmInfoResponse::offset() const {
  // @@protoc_insertion_point(field_get:ShmInfoResponse.offset)
  return _internal_offset();
}
inline void ShmInfoResponse::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
}
inline void ShmInfoResponse::set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ShmInfoResponse.offset)
}

// -------------------------------------------------------------------

// StatInfoResponse

// required int64 num_samples = 1;
inline bool StatInfoResponse::_internal_has_num_samples() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatInfoResponse::has_num_samples() const {
  return _internal_has_num_samples();
}
inline void StatInfoResponse::clear_num_samples() {
  num_samples_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatInfoResponse::_internal_num_samples() const {
  return num_samples_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatInfoResponse::num_samples() const {
  // @@protoc_insertion_point(field_get:StatInfoResponse.num_samples)
  return _internal_num_samples();
}
inline void StatInfoResponse::_internal_set_num_samples(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  num_samples_ = value;
}
inline void StatInfoResponse::set_num_samples(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_samples(value);
  // @@protoc_insertion_point(field_set:StatInfoResponse.num_samples)
}

// required int32 num_reads = 2;
inline bool StatInfoResponse::_internal_has_num_reads() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatInfoResponse::has_num_reads() const {
  return _internal_has_num_reads();
}
inline void StatInfoResponse::clear_num_reads() {
  num_reads_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfoResponse::_internal_num_reads() const {
  return num_reads_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfoResponse::num_reads() const {
  // @@protoc_insertion_point(field_get:StatInfoResponse.num_reads)
  return _internal_num_reads();
}
inline void StatInfoResponse::_internal_set_num_reads(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_reads_ = value;
}
inline void StatInfoResponse::set_num_reads(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_reads(value);
  // @@protoc_insertion_point(field_set:StatInfoResponse.num_reads)
}

// required int32 num_writes = 3;
inline bool StatInfoResponse::_internal_has_num_writes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatInfoResponse::has_num_writes() const {
  return _internal_has_num_writes();
}
inline void StatInfoResponse::clear_num_writes() {
  num_writes_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfoResponse::_internal_num_writes() const {
  return num_writes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfoResponse::num_writes() const {
  // @@protoc_insertion_point(field_get:StatInfoResponse.num_writes)
  return _internal_num_writes();
}
inline void StatInfoResponse::_internal_set_num_writes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_writes_ = value;
}
inline void StatInfoResponse::set_num_writes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_writes(value);
  // @@protoc_insertion_point(field_set:StatInfoResponse.num_writes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_samples_2eproto
